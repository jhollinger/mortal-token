== MortalToken, because some tokens shouldn't live forever

MortalToken is a library for creating tokens that self-destruct after a specified time. No need to store and look up the 
token; it is self-verifying and self-expiring.

The default lifespan is two of your Earth days. This does *not* mean "48 hours from when it was created". It means that 
the key will be valid throughout "today" and "tomorrow". If the lifespan were one day, a key created at 23:59 would expire 
in one minute at 00:00.

My original use case was login auth tokens for some simple Sinatra apps. I can also see it being useful for API auth.

Steps:

1. Generate a new token
2. Give the client the resulting hash and salt
3. Time passes
4. Receive a hash and salt from client
5. Reconstitute the token from the salt, and test if the hashes match. If not, the token has expired (or was forged).

Read the full documentation at {jordanhollinger.com/docs/mortal-token/}[http://jordanhollinger.com/docs/mortal-token/].

== Disclaimer

This is not intended to be the most secure thing ever, but for all I know it's less secure than I think. Suggestions and 
pull requests are welcomed.

Also, it is very early and the API may go through significant changes.

== Install

  [sudo] gem install mortal-token

Or add it to your Gemfile
  gem "mortal-token"

== Use

Though my example is a Sinatra app, it need not be. In fact, it needn't have anything to do with the Web. It's useful
anytime you want a self-contained, self-expiring token (w/ salt).

  require 'mortal-token'

  # You MUST set a secret key! Otherwise, anyone who looks at the source code will be able to forge tokens.
  MortalToken.secret = 'asdf092$78roasdjfjfaklmsdadASDFopijf98%2ejA#Df@sdf'

  post '/login' do
    if login_ok?
      token = MortalToken.new
      session[:token] = token.hash
      session[:salt] = token.salt
      redirect '/secret'
    end
  end

  get '/secret' do
    token = MortalToken.new(session[:salt])
    if token == session[:token]
      'Welcome, nice token!'
    else
      'Go away, your token is expired or forged!'
    end
  end

== Checking tokens

These are all valid means of checking a token's validity. In this case, they will all return true. == and === are treated the same.

  token_a = MortalToken.new
  token_b = MortalToken.new(token_a.salt)

  token_a == token_b
  token_a == token_b.to_s
  token_a == token_b.hash
  token_a.to_s == token_b.to_s
  token_a.hash == token_b.hash
  token_a.to_s == token_b.hash

== Tweak token parameters

You may tweak certain parameters of the library in order to make it more secure, less, faster, etc.
These are the defaults (see the MortalToken class for documentation about each parameter):

  MortalToken.rounds = 5
  MortalToken.valid_across = 2
  MortalToken.max_salt_length = 50
  MortalToken.min_salt_length = 10

== License
Copyright 2012 Jordan Hollinger

Licensed under the Apache License
